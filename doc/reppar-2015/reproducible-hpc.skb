(define %document-url
  ;; This the URL where the source of this document can be found.
  "http://git.savannah.gnu.org/cgit/guix/maintenance.git/tree/doc/reppar-2015")

(eval-when (expand load eval)
  ;; Augment the search path so that both the examples and the Guix
  ;; modules are found.
  (let ((file (assoc-ref (current-source-location) 'filename)))
    (for-each (lambda (dir)
                (set! %load-path (cons dir %load-path))
                (set! %load-compiled-path
                      (cons dir %load-compiled-path)))
              (list (string-append (getenv "HOME") "/.config/guix/latest")
                    (string-append (dirname file) "/code")))))

;; Ignore the user-defined packages.
(unsetenv "GUIX_PACKAGE_PATH")

(use-modules (skribilo package lncs)
	     (skribilo engine latex)
	     (skribilo biblio author)
	     (skribilo biblio abbrev)
             (skribilo source)
             (skribilo source lisp)
	     (skribilo engine)
	     (skribilo writer)
	     (skribilo ast)
	     (skribilo evaluator)
             (guix packages) (guix derivations)
             ((guix store) #:prefix guix:)
             (guix hash) (guix base64)
             ((guix serialization) #:select (write-file))
             (my-openmpi)
             (gnu packages)
             (ice-9 i18n))

(define-values (%openmpi-path %openmpi-hash)
  ;; Here we connect to the Guix build daemon to get information about
  ;; the software environment we are talking about.
  (guix:with-store store
    (let ((drv (package-derivation store openmpi)))
      (values
        ;; Compute the /gnu/store file name of our Open MPI.
        (derivation->output-path drv)

        ;; Here we go as far as building it (if it's not already built)
        ;; and computing its hash.
        (parameterize ((guix:current-build-output-port (current-error-port)))
          (build-derivations store (list (package-derivation store openmpi)))
          (call-with-values open-sha256-port
            (lambda (port get-hash)
              (write-file (derivation->output-path drv) port)
              (force-output port)
              (get-hash))))))))

(define (---) ; emdash
  (resolve (lambda (n e env)
             (if (engine-format? "html" e)
                 (! "&mdash;")
                 "---"))))

(define (--) ; endash
  (resolve (lambda (n e env)
             (if (engine-format? "html" e)
                 (! "&ndash;")
                 "--"))))

(define (url url)
  ;; Return a URL typeset in a fixed-with font.
  (ref :url url :text (tt url)))

(define (number* number)
  ;; Return NUMBER correctly formatting according to English conventions.
  (number->locale-string number 0
                         (or (false-if-exception
                               (make-locale LC_ALL "en_US.utf8"))
                             (make-locale LC_ALL "en_US.UTF-8"))))

;; Abbreviate author first names.
(markup-writer '&bib-entry-author
   :action (lambda (n e)
	     (let ((names (markup-body n)))
	       (evaluate-document
	         (if (string? names)
		     (abbreviate-first-names names)
		     names)
		 e))))

;; Abbreviate book titles in bibliography entries.
(markup-writer '&bib-entry-booktitle
   :action (lambda (n e)
             (define %abbreviations
               (append %cs-conference-abbreviations
                       %ordinal-number-abbreviations
                       %common-booktitle-abbreviations))

             (let ((title (markup-body n)))
               (evaluate-document
                (it (abbreviate-markup %abbreviations
                                        title)) e))))

(bibliography "../els-2013/guix.sbib")
(bibliography "reppar.sbib")
              
(let* ((latex (find-engine 'latex))
       (usep  (engine-custom latex 'usepackage)))
  (engine-custom-set! latex 'usepackage
                      (string-append usep "
\\usepackage{floatrow}
\\floatsetup[figure]{font=footnotesize}
\\setlength{\\intextsep}{5pt plus 1.0pt minus 2.0pt}
"))
  (engine-custom-set! latex 'source-comment-color
                      "#776600"))


(document :title [Reproducible and User-Controlled
Software Environments in HPC with Guix]
   :author (list (author :name "Ludovic Courtès"
		    :affiliation "Inria"
		    :address (list "Bordeaux, France"))
		 (author :name "Ricardo Wurmus"
		    :affiliation "Max Delbrück Center for Molecular
		    Medicine"  ;;in the Helmholtz Association
		    :address (list "Berlin, Germany"))
                 ;; + others...
		    )
   
   (abstract
    [Support teams of high-performance computing (HPC) systems often
find themselves between a rock and a hard place: on one hand, they
understandably administrate these large systems in a conservative way,
but on the other hand, they try to satisfy their users by deploying
up-to-date tool chains as well as libraries and scientific software.
HPC system users often have no guarantee that they will be able to
reproduce results at a later point in time, even on the same
system,(---)software may have been upgraded, removed, or recompiled
under their feet,(---), and they have little hope of being able to
reproduce the same software environment elsewhere.  We present
GNU,(~)Guix and the functional package management paradigm and claim
that it can improve reproducibility and sharing among researchers,
illustrating with representative use cases.])
   
   (chapter :title [Introduction]
      
      (p [HPC system administration has to satisfy two seemingly
contradictory demands: on one hand administrators seek stability, which
leads to a conservative approach to software management, and on the
other users demand recent tool chains and huge scientific software
stacks.  In addition, users often need different versions and different
variants of a given software package.  To satisfy both, support teams
always play the role of ``distribution maintainers'': they build and
install tool chains, libraries, and scientific software packages
manually,(---)multiple variants thereof,(---)and make them available
,(it [via]) ``environment modules'',(ref :bib 'furlani1991:modules), which
allows users to pick the specific packages they want.])
      (p [Unfortunately, software is often built and installed in an
,(it [ad hoc]) fashion, leaving users little hope of redeploying the
same software environment on another system.  Worse, support teams
occasionally have to remove installed software or to upgrade it in
place, which means that users may eventually find themselves unable to
reproduce their software environment, ,(emph [even on the same
system]).])
      (p [Recently-developed tools such as EasyBuild ,(ref :bib
'geimer2014:easybuild) and Spack ,(ref :bib
'gamblin:spack-web) address part of the problem by automating package
builds, supporting non-root users, and adding facilities to create
package variants.  However,
these tools fall short when it comes to build reproducibility.  First,
build processes can trivially refer to tools or libraries already
installed on the system.  Second,
the ,(it [ad hoc]) naming conventions they rely on to identify builds
fail to capture the directed acyclic graph (DAG) of dependencies that
led to this particular build.])
      (p [GNU,(~)Guix is a general-purpose package manager that
implements the functional package management paradigm pioneered by Nix
,(ref :bib '(dolstra2004:nix courtes2013:functional)).  Many of its
properties and features make it attractive in a multi-user HPC context:
per-user profiles, transactional upgrades and roll-backs, and, more
importantly, a controlled build environment to maximize reproducibility.
,(numref :text [Section] :ident "rationale") details our motivations.
,(numref :text [Section] :ident "functional") describes the functional
package management paradigm, its implementation in Guix, its impact on
reproducibility, and how it can be applied to HPC systems.  ,(numref
:text [Section] :ident "use-cases") gives concrete use cases where Guix
empowers users while guaranteeing reproducibility and sharing, while
,(numref :text [Section] :ident "limitations") discusses limitations and
remaining challenges.  Finally, ,(numref :text [Section] :ident
"related") compares to related work, and ,(numref :text [Section] :ident
"conclusion") concludes.]))
   
   (chapter :title [Rationale] :ident "rationale"
      
      (p [Recent work on reproducible research insufficiently takes
software environment reproducibility into account.  For example, the
approach for verifiable computational results described in ,(ref :bib
'gavish2011:universal) focuses on workflows and conventions but does not
mention the difficulty of reproducing full software environments.
Likewise, the authors of ,(ref :bib 'stanisic2014:effective) propose a
methodology for reproducible research experiments in HPC.  To address
the software-environment reproducibility problem they propose two
unsatisfying approaches: one is to write down the
version numbers of the dependencies being used, which is insufficient,
and the other is to save and reuse full virtual machines (VMs), which poses a
real challenge for performance and make verifiability
impractical,(---)peers would have to download large images and would be
unable to combine them with their own software environment.])
      (p [Yet, common practices on HPC systems hinder reproducibility.
The vast majority of HPC systems run GNU/Linux but for understandable
stability reasons, they often run old distributions that are rarely
updated.  Thus, packages provided by the distribution are largely
dismissed.  Instead support teams install packages from third-party
repositories,(---)but then they clobber the global ,(tt [/usr])
prefix, which sysadmins may want to keep under control,(---), or install
them from source by
themselves and make them available through environment modules
,(ref :bib 'furlani1991:modules).  Modules allow users to choose different
versions or variants of the packages they use without interfering with
each others.  However, when installed software is updated in place or
removed, users suddenly find themselves unable to reproduce the software
environment they were using.  Given these practices, reproducing the
exact same software environment on a ,(emph [different]) HPC system
seems out of reach.  It is nonetheless a very important property: it
would allow users to assess the impact of the hardware on the software's
performance,(---)something that is very valuable in particular for
developers of run-time systems such as StarPU ,(ref :bib
'augonnet2009:starpu),(---)and it would allow other researchers to
reproduce experiments on their system.])
      (p [Essentially, by deploying software and environment modules,
HPC support teams find themselves duplicating the work of GNU/Linux
distributions, but why is that?  Historical package managers such as
APT and RPM suffer from
several limitations.  First, package binaries that every user installs,
such as ,(code [.deb]) files, are actually built on the package
maintainer's machine, and details about the host
may leak into the binary that is uploaded,(---)a shortcoming that is now
being addressed (see ,(numref :text [Section] :ident "related").])
      (p [Second, while it is in theory possible for a user to define
their own variant of a package, as is often needed in HPC, this
happens to be often difficult in practice.  Users of RPM-based systems,
for example, may be able to customize a ,(code [.spec]) file to
build a custom, relocatable RPM package, but only the administrator can
install the package alongside its dependencies and register it in the
central package database.  A user without super-user privileges cannot
write to the central ,(code [yumdb]), and as ,(code [yum]) does not
support per-user package databases, the user has to fall back to the
lower-level ,(code [rpm]) tool to be able to use a separate package
registry, losing higher-level package management features such as
dependency analysis as a result.  Since RPM package databases cannot
be composed, a user would need to manually track down and register the
complete graph of dependencies with the separate, user-owned package
database, a tedious process resulting in needless duplication and
preventing sharing.])
      (p [Third, these tools implement an ,(emph
[imperative]) and ,(emph [stateful]) package management model, as Dolstra
et al. explain in ,(ref :bib 'dolstra2004:nix).  It is
imperative in the sense that it modifies the set of available packages
in place.  For example, upgrading libc means that suddenly all the
installed packages start using the new libc version; switching to an
alternative MPI implementation, or upgrading the OpenMP run-time library
means that suddenly all the installed applications and libraries start
using them.  It is stateful in the sense that the system state after a
package management operation depends on its previous state.  Namely, the
system state at a given point in time is the result of the series of
installation and upgrade operations that have been made over time, and
there may be no way to reproduce the exact same state elsewhere.  These
properties are a serious hindrance to reproducibility.]))

   (chapter :title [Functional Package Management] :ident "functional"
      
      (p [,(it [Functional paradigm.]) Functional package management is
a discipline that transcribes the functional programming paradigm to
software deployment: build and installation processes are viewed as pure
functions in the mathematical sense,(---)whose result depends
exclusively on the inputs,(---), and their result is a value,(---)that
is, an immutable directory.  Since build and installation processes are
pure functions, their results can effectively be ``cached'' on
disk.  Likewise, two
independent runs of a given build process for a given set of inputs
should return the same value,(---),(it [i.e.]), bit-identical
files.  This approach was first described and implemented in the Nix
package manager ,(ref :bib 'dolstra2004:nix).  Guix reuses low-level
mechanisms from Nix to implement the same paradigm, but offers a unified
interface for package definitions and their implementation, all embedded
in a single programming language ,(ref :bib 'courtes2013:functional).])
      (p [An obvious challenge is the implementation of this paradigm:
how can build and install processes be viewed as pure?  To obtain that
property, Nix and Guix ensure tight control over the build environment.
In both cases, build processes are started by a privileged daemon that
always runs them in ``containers'' as implemented by the kernel Linux;
that is, they run in a chroot environment, under a dedicated user ID,
with a well-defined set of environment variables,
with separate name spaces for PIDs, inter-process communication (IPC),
networking, and so on.  The chroot environment contains
only the directories corresponding to the explicitly declared inputs.
This ensures that the build process cannot
inadvertently end up using tools or libraries that it is not supposed to
use.  The separate name spaces ensure that the build process cannot
communicate with the outside world.
Although it is not perfect as we will see in ,(numref :text [Section]
:ident "limitations"), this technique gives us confidence that build
processes can indeed be viewed as pure functions, with 
reproducible results.])
      
      (p [Each build process produces one or more files in directories
stored in a common place called ,(emph [the store]), typically the ,(tt
[/gnu/store]) directory.  Each entry in ,(tt [/gnu/store]) has a name
that includes a hash of ,(emph [all the inputs]) of the build process
that led to it.  By ``all
the inputs'', we really mean all of them: this includes of course
compilers and libraries, including the C library, but also build
scripts and environment variable values.  This is recursive: the
compiler's own directory name is a hash of the tools and libraries used
to build, and so on, until a set a pre-built binaries used
for bootstrapping purposes,(---)which can in turn be rebuilt using
Guix ,(ref :bib 'courtes2013:functional).  Thus, for each package that
is built, the system has access to the ,(emph [complete DAG]) of
dependencies used to build it.])
      
      (figure
         :legend [Guix package recipe of Open,(~)MPI.]
         :ident "fig-recipe"
         
         (prog
            (source :language scheme :file "code/my-openmpi.scm"
               :definition 'openmpi)))

      (p [Package recipes in Guix are written in a domain-specific
language (DSL) embedded in the Scheme programming language.  ,(numref
:text [Figure] :ident "fig-recipe") shows, as an example, the recipe to
build the Open,(~)MPI library.  The ,(tt [package]) form evaluates to a ,(emph [package
object]), which is just a ``regular'' Scheme value; the ,(tt [define])
form defines the ,(tt [openmpi]) variable to hold that value.])
      
      (figure
         :legend [Querying the dependencies of a package object.]
         :ident "fig-query"
         
         (prog :mark #f
            (source :language scheme :file "code/query-package.scm"
                :start ";;!start"))

         (p [... yields:])

         (prog :line #f
            (source :language scheme
               (object->string (primitive-load "code/query-package.scm")))))
            
      (p [Line ,(ref :line
"recipe-build-system") specifies that the package is to be built
according to the GNU standards,(---),(it [i.e.]),
the well-known ,(tt [./configure && make && make install]) sequence
(similarly, Guix defines ,(tt [cmake-build-system]), and so on.)
The ,(tt [inputs]) field on line ,(ref :line "recipe-inputs") specifies
the direct dependencies of the package.  The field refers to the
,(tt [hwloc]), ,(tt [gfortran-4.8]), and ,(tt [pkg-config]) variables,
which are also bound to package objects (their definition is not shown
here.)  It would be inconvenient to specify all the standard inputs,
such as Make, GCC, Binutils so these are implicit here;
they are provided by ,(tt [gnu-build-system]), which is responsible for
compiling package objects to an intermediate representation.
Since we are manipulating ``normal'' Scheme objects, we can use the API
of Guix to query those package objects, as illustrated with the code in
,(numref :text [Figure] :ident "fig-query"), which queries the name and
version of the direct and indirect dependencies of our package,(footnote

[This is an ``active paper'' written in Skribilo, a Scheme-based authoring
tool, which allows us to use Guix and run this code from the document.]).])
      (p [With that definition in place, running ,(tt [guix build
openmpi]) returns the directory name
,(tt %openmpi-path).  If
that directory did not already exist, the daemon spawns the build
process in its isolated environment with write access to this directory.
Of course users never have to type these long ,(tt [/gnu/store]) file
names.  They can install packages in their ,(emph [profile]) using
the ,(tt [guix package]) command, which essentially creates symbolic
links under ,(tt [~/.guix-profile]).  It is then a matter of defining
the search paths for the compiler, linker, and other tools ,(it [via])
environment variables.  Fortunately, Guix keeps track of that and the
,(tt [guix package --search-paths]) command returns all the necessary
environment variable definitions in Bourne shell syntax.  For example,
when both the GCC tool chain and Open,(~)MPI are installed, the command
returns definitions for the ,(tt [PATH]), ,(tt [CPATH]), and ,(tt
[LIBRARY_PATH]) environment variables, and these definitions can be
passed to the ,(tt [eval]) shell built-in command.]))
   
   (chapter :title [Use Cases] :ident "use-cases"

      (p [We explore practical use cases where Guix improves
experimentation reproducibility for a user of a given system, supports
the deployment of complex software stacks, allows a software environment
to be replicated on another system, and finally allows fine
customization of the software environment.])

      (section :title [Usage Patterns on an HPC Cluster] ;MDC Berlin

         (p [One of the key features of Guix and Nix is that they
securely permit unprivileged users to install packages in the store
,(ref :bib 'dolstra2004:nix).  To build a package, the ,(tt [guix])
commands connect to the build daemon, which then performs the build (if
needed) on their behalf, in the isolated environment.
When two users build the exact same package, both end up using the exact
same ,(tt [/gnu/store]) file name and storage is shared.  If a user
tries to build, say, a malicious version of the C library, then the
other users on the system will not use it, simply because they cannot
guess its ,(tt [/gnu/store]) file name,(---)unless
they themselves explicitly build the very same modified C library.])
         (p [At the Max Delbrück Center for Molecular Medicine (MDC),
Berlin, the store is shared among 250 cluster
nodes and an increasing number of user workstations, and is now gradually
replacing other methods
of software distribution, such as statically linked binaries on group
network shares, relocatable RPMs installed into group prefixes,
one-off builds on the cluster, and user-built software
installed in home directories.  This proved particularly
useful in the ongoing efforts to move dozens of users and their custom software
environments from an older cluster running Ubuntu to a new cluster
running a version of CentOS, because software packaged with Guix does
not depend on any of the host system's libraries and thus can be used
on very different systems without any changes to the packages.
Research groups now have a shared Guix profile for common
applications, whereas individual users can manage their own
profiles for custom software, legacy versions of bioinformatics tools
to reproduce published results, bleeding-edge tool chains, or even for
complete workflows.])

         (figure
            :legend [Declaring the set of packages to be installed in a
            profile.]
            :ident "fig-manifest"
            
            (prog :line #f
               (source :language scheme :file "code/manifest.scm")))

         (p [Guix users have a default profile in ,(tt
[~/.guix-profile]) but they can create independent profiles in
arbitrary places of the file system.  Guix supports two ways to manage a
profile.  The first one is to make transactions that add, upgrade, or
remove packages in the profile: ,(tt [guix package --install openmpi
--remove mpich2]) installs Open,(~)MPI and removes MPICH2
in a single transaction that can be rolled back.  The
second approach is to ,(emph [declare]) the desired contents of the
profile and make that effective: the user writes in a file a code
snippet that lists the requested packages (see ,(numref :text [Figure]
:ident "fig-manifest")) and then runs ,(tt [guix package
--manifest=my-packages.scm]).])
         (p [This declarative profile management makes it easy to
replicate a profile, but it is symbolic: it uses whatever package
objects the variables are bound to (,(tt [gnu-make]), ,(tt
[gcc-toolchain]), etc.), but these variables are typically defined in
the ,(tt [(gnu packages …)]) modules that Guix comes with.  Thus the
precise packages being installed depend on the version of Guix that is
available.  Specifying the Git commit of Guix
in addition to the declaration in
,(numref :text [Figure] :ident "fig-manifest") is all it takes to
reproduce the exact same ,(tt [/gnu/store]) items.])
         (p [Another approach to achieve bit-identical reproduction of a
user's profile is by saving the contents of its transitive closure using ,(tt [guix
archive --export]).  The resulting archive can be transferred to another
system and restored at any point in time using ,(tt [guix archive
--import]).  This should significantly facilitate experimentation and
sharing among peers.]))

      (section :title [Customizing Packages]  ;MORSE
         :ident "customizing"
         
         (p [Our colleagues at Inria in the HiePACS and Runtime teams
develop a complete linear algebra software stack going from sparse
solvers such as PaStiX and dense solvers such as Chameleon,
to run-time support libraries and compiler extensions such as StarPU
,(ref :bib 'augonnet2009:starpu) and hwloc.  While
developers of simulations want to be able to deploy the whole stack,
developers of solvers only need their project's
dependencies, possibly several variants thereof.  For instance,
developers of Chameleon may want to test their software against several
versions of StarPU, or against variants of StarPU built with different
compile-time options.  Finally, developers of the lower-level layers,
such as StarPU, may want to test the effect of changes they make on
higher-level layers.])
         
         (figure
            :legend [Defining variants of the default recipe for
            StarPU.]
            :ident "fig-variants"
            
            (prog :line #f :mark #f
               (source :language scheme :file "code/starpu.scm"
                  :start ";!begin-starpu-variants"
                  :stop ";!end-starpu-variants")))

         (p [This use case leads to two requirements: that users be able
to customize and non-ambiguously specify a package DAG, and that they be
able to reproduce any variant of their package DAG.  Guix allows them to
define variants; the code for these variants can be stored in a
repository of their own and made visible to the ,(tt [guix])
commands by defining the ,(tt [GUIX_PACKAGE_PATH]) environment variable.
,(numref :text [Figure] :ident "fig-variants") shows an example of such
package variants: based on the pre-existing ,(tt [starpu]) variable, the
first variant defines a package for a new StarPU release candidate,
simply by changing its ,(tt [source]) field, while the second variant
adds the optional dependency on the SimGrid simulator,(---)a variant
useful to scheduling practitioners, but not necessarily to solver
developers.])
         (p [These StarPU package definitions are obviously useful to
users of StarPU: they can install them with ,(tt [guix package -i
starpu]) and similar commands.  But they are also useful to StarPU
developers: they can enter a ``pristine'' development environment
corresponding to the dependencies given in the recipe by running ,(tt
[guix environment starpu --pure]).  This command spawns a shell where
the usual ,(tt [PATH]), ,(tt [CPATH]) etc. environment variables are
redefined to refer precisely to the inputs specified in the recipe.  This
amounts to creating a profile on the fly, containing only the tools and
libraries necessary when developing StarPU.  This is notably useful when
dealing with build systems that support optional dependencies.])
         
         (figure
            :legend [Defining a function that returns a package object
for the Chameleon solver.]
            :ident "fig-chameleon"

            (prog :line #f :mark #f
               (source :language scheme :file "code/starpu.scm"
                  :start ";;!begin-chameleon"
                  :stop ";;!end-chameleon")))

         (p [Now that we have several StarPU variants, we
want to allow direct
and indirect users to select the variant that they want.  A simple way to
do that is to write, say, a function that takes a
,(tt [starpu]) parameter and returns a package that uses it as its input
as show in ,(numref :text
[Figure] :ident "fig-chameleon").  To allow users to refer
to one or the other variant at the command line, we use different
values for the ,(tt [name]) field.])
         
         (figure
            :legend [Rewriting a package DAG by changing a specific input.]
            :ident "fig-override"
            
            (prog :line #f :mark #f
               (source :language scheme :file "code/starpu.scm"
                  :start ";;!begin-override-input"
                  :stop ";;!end-override-input")))

         (p [This approach is reasonable when there is a small number of
variants, but it does not scale to more complex DAGs.  As an example,
StarPU can be built with MPI support, in which case Chameleon also needs
to be explicitly linked against the same MPI implementation.  Users may
want to replace all occurrences of an MPI implementation in the DAG
rooted at Chameleon with a different implementation.  One way to do that
is by writing a function that recursively adjusts the package labeled
,(tt ["mpi"]) in the ,(tt [inputs]) field of packages.  This is what the
,(tt [override-input]) function in ,(numref :text [Figure] :ident
"fig-override") does.
 No matter how complex the transformations are, a package
object unambiguously represents a reproducible build process.]))

      #;(section :title [Going Further]  ;active papers + gexps
         :ident "active"
         
         (p [``Executable'' or ``active'' research papers have become an
active research domain looking for tools to tightly make have
experimental reproducibility ``built in'' papers themselves, with some
focusing on ways to identify computational results ,(ref :bib
'gavish2011:universal) and others focusing on the integration of the
software and computational environments with authoring tools ,(ref :bib
'(schulte2011:org-reproducible nowakowski2011:collage)).])
         (p [This paper is written using Skribilo, a Scheme-based
authoring tool based on Skribe ,(ref :bib 'gallesio2005:skribe).
Because Guix is itself a Scheme library, we can easily insert
information about the software environment as in ,(numref :text [Figure]
:ident "fig-query"), or note that the recipe in ,(numref :text [Figure]
:ident "fig-recipe") leads to ,(tt %openmpi-path) and that the SHA256
hash of its content is ,(tt (base64-encode
%openmpi-hash)) ,(let ((here (current-source-location)))
   (footnote [Check out the source code of this document at ,(url
%document-url), around line ,(assoc-ref here 'line) of file ,(tt
(assoc-ref here 'filename)).])).  With a bit of ``plumbing'', authors
could achieve similar results with other document authoring systems, for
instance with Org-Babel ,(ref :bib 'schulte2011:org-reproducible).])
         (p [Our vision is that authors would integrate all the
information necessary and sufficient to reproduce ,(emph [exactly]) the
software environment described in their paper.  In practice that would
include the Git commit of the Guix being used and the Git commits of
additional repositories containing package recipes, if needed.
Incorporating ,(tt [/gnu/store]) file names in the document would
provide those interested in reproducing the software environment with a
``check sum'' while the content hash constitutes a ``proof of build''.])
         (p [We could go further an imagine papers that directly
evaluate g-expressions,(---)Guix's DSL for primitive build expressions
that use Guix packages,(---)to run the tool chain that produces results
that appear in the paper.  The Guix daemon can delegate builds ,(it
[via]) its offloading mechanism; this could perhaps be directly
integrated with batch schedulers like Slurm to allow HPC applications to
be not only built but also run ,(it [via]) Guix.])))

   (chapter :title [Limitations and Challenges]
      :ident "limitations"
      
      (p (emph [Privileged daemon.]) [ Nix and Guix address many of the
reproducibility issues encountered in package deployment, and Guix
provides APIs that can facilitate the
development of package variants as is useful in HPC.  Yet, to our
knowledge, neither Guix nor Nix are widely deployed on HPC systems.  An
obvious reason that limits adoption is the requirement to have the build
daemon run with root privileges,(---)without which it would be unable
to use the Linux kernel container facilities that allow it to isolate
build processes and maximize build reproducibility.  System
administrators are wary of installing privileged daemons, and so HPC
system users trade reproducibility for practical approaches.])

      (p (emph [Cluster setup.])[ All the ,(tt [guix]) commands are
actually clients of the daemon.  In a typical cluster setup, system
administrators may want to run a single daemon on one specific node and
to share ,(tt [/gnu/store]) among all the nodes.  At the time of
writing, Guix does not yet allow communication with a remote daemon.
For this reason, Guix users at the MDC are required to manage their
profiles from a specific node; other nodes can use the profiles, but not
modify them.  Allowing the ,(tt [guix]) commands to communicate with a
remote daemon will address this issue.])
      (p [Additionally, compute nodes typically lack
access to the Internet.  However, the daemon needs to be able to download
source code tarballs or pre-built binaries from external servers.  Thus,
the daemon must run on a node with Internet access, which could be
contrary to the policy on some clusters.])

      (p (emph [Non-determinism.])[ Despite the use of
isolated containers to run build processes, there are still a few sources
of non-determinism that build systems of packages might use and
that can impede reproducibility.  In particular,
details about the operating system kernel and the hardware being used
can ``leak'' to build processes.  For example, the kernel Linux provides
system calls such as ,(tt [uname]) and interfaces such as
,(tt [/proc/cpuinfo]) that leak information about the host; independent
builds on different hosts could lead to different results if this
information is used.  Likewise, the ,(tt [cpuid]) instruction leaks
hardware details.])
      (p [Fortunately, few software packages depend on this information.
Yet, the proportion of packages depending on it is higher in the HPC
world.  A notable example is the ATLAS linear algebra system, which
fine-tunes itself based on details about the CPU micro-architecture.
Similarly, profile-guided optimization (PGO), where the compiler
optimizes code based on a profile gathered in a previous run, undermines
reproducibility.  Running build processes in full-blown VMs
would address some of these issues, but with a potentially
significant impact on build performance, and possibly preventing
important optimization techniques in the HPC context.])

      (p (emph [Proprietary software.])[ GNU,(~)Guix does not provide
proprietary software packages.  Unfortunately, proprietary software is
still relatively common in HPC, be it linear algebra libraries or GPU
support.  Yet, we see it as a strength more than a limitation.  Often,
these ``black boxes'' inherently limit reproducibility,(---)how is one
going to reproduce a software environment without permission
to run the software in the first place?  What if the software
depends on the ability to ``call home'' to function at all?  More
importantly, we view reproducible software environments and reproducible
science as a tool towards improved and shared knowledge;
developers who deny the freedom to study and modify their code work
against this goal.]))

   (chapter :title [Related Work] :ident "related"
      
      (p (emph [Reproducible builds.]) [ Reproducible software
environments have traditionally not been a major concern until recently.
One of the earliest pieces of work in this area is the Vesta software configuration
system ,(ref :bib 'heydon2000:caching).  Vesta provides a DSL that
allows users to describe build operations, similar to Nix
,(ref :bib 'dolstra2004:nix). ]

;; Guix reuses the
;; Nix build daemon, but instead provides a set of embedded DSLs and to
;; describe both high-level package recipes and fine-grain build
;; operations, as well as a unified programming framework ,(ref :bib
;; 'courtes2013:functional).  Guix also goes a bit further by having
;; completely pure build environments, without ,(tt [/bin/sh]).  While
;; this may sound like a detail, adding ,(tt [/bin/sh]) to the chroot has
;; proved to be a serious barrier to reproducibility in practice ,(ref :bib
;; 'courtes2013:functional).

      [More recently, projects such as Debian's Reproducible, Fedora's
Mock, or Gitian have intended to improve reproducibility and
verifiability of mainstream package distributions.
Google's recent Bazel build tool relies on container facilities provided
by the kernel Linux and provides another DSL to describe build
operations.])
      (p [Reproducibility can be
achieved with heavyweight approaches such as full operating system
deployments ,(ref :bib 'jeanvoine2013:kadeploy3), VM
deployments ,(ref :bib 'vangorp2011:share), and full-system
container-based deployments ,(ref :bib 'kniep2015:reproducibility).  In
addition to being resource-hungry, these approaches are coarse-grain
and do not compose: if two different VM or Docker images provide useful
features or packages, one has to make a binary choice and
cannot combine the features or packages they offer.  A side issue is
security: it was recently reported that many official Docker images are
plagued with serious unfixed security vulnerabilities ,(ref :bib
'gummaraju2015:docker).])
      (p (emph [HPC package management.]) [ In the HPC community,
efforts have focused primarily on the automation of software deployment
and the ability for users to customize their build environment
independently of each other.  The latter has been achieved by
``environment modules'', a simple but efficient tool set that is still
widely used today ,(ref :bib 'furlani1991:modules).  Build and
deployment automation is more recent with the development of specialized
package management tools such as EasyBuild ,(ref :bib
'geimer2014:easybuild) and Spack ,(ref :bib 'gamblin:spack-web).])
      (p [Both EasyBuild and Spack have the advantage of being
installable by unprivileged users since they do not rely on privileged
components, unlike Guix and Nix.  The downside is that they cannot use
the kernel's container facilities, which seriously hinders
build reproducibility.  When used in the user's home directories, 
each user may end up
rebuilding the same compiler, libraries, etc., which can be costly in
terms of CPU, bandwidth, and disk usage.  Conversely, Nix and Guix
support safe sharing of builds.])
      (p [EasyBuild aims to support multiple package variants, such as
packages built with different compilers, or linked against different MPI
implementations.  To achieve that, it relies on directory naming
conventions; for instance, ,(tt [OpenMPI/1.7.3-GCC-4.8.2]) contains
packages built with the specified MPI implementation and compiler.  Such
conventions fail to capture all the complexity of the DAG and
configuration space.  For instance, the convention arbitrarily omits the
C library, linker, or configuration flags being used.])
      (p [EasyBuild is tightly integrated with environment modules ,(ref
:bib 'furlani1991:modules), which are familiar to most users of HPC
systems.  While modules provide users with flexible environments, they
implement an imperative, stateful paradigm: users run a sequence of ,(tt
[module load]) and ,(tt [module unload]) commands that ,(emph [alter])
the current environment.  This can make it much harder to reason about
and reproduce an environment, as opposed to the declarative approaches
implemented by ,(tt [guix package --manifest]) and ,(tt [guix
environment]).])
      (p [Like EasyBuild and similarly to Guix, Spack implements build
recipes as first-class objects in a general-purpose language, Python,
which facilitates customization and the creation of package variants.
In addition, Spack provides a rich command-line interface that allows
users to express variants similar to those discussed in ,(numref :text
[Section] :ident "customizing").  This appears to be very convenient for
common cases, although there are limits to the expressivity and
readability of such a compact syntax.]))
   
   (chapter :title [Conclusion] :ident "conclusion"
      
      (p [Functional package managers provide the foundations for
reproducible software environments, while still allowing fine-grain
software composition and not imposing high disk and RAM costs.
GNU,(~)Guix builds on the foundations of Nix and provides a unified set
of user and programming interfaces.  To date, it comes with
,(number* (fold-packages (lambda (p n) (+ 1 n)) 0)) packages, including many of the common
HPC tools and libraries as well as around 40 bioinformatics packages.
It is deployed on the clusters of the MDC Berlin, 
and being discussed as one of the packaging options by
the Open Bioinformatics Foundation, a non-profit for the biological
research community.  We hope to see more HPC deployments of Guix in the
foreseeable future.])
      (p [GNU,(~)Guix benefits from contributions by about 20 people
each month.  It is the foundation of the Guix System Distribution, a
standalone, reproducible GNU/Linux distribution.]))
      
   (chapter :title [Acknowledgments] :number #f
      
      (p [We would like to thank colleagues at Inria for insightful
discussions and comments on an earlier draft: Florent Pruvost, Emmanuel
Agullo, and Andreas Enge.  We are grateful to the Guix contributors who
keep improving the system.]))
   
   (references))
   
;; Local Variables:
;; compile-command: "skribilo -t latex -o reproducible-hpc.tex reproducible-hpc.skb && rubber --pdf reproducible-hpc.tex"
;; ispell-local-dictionary: "american"
;; comment-start: ";;"
;; comment-end: ""
;; indent-tabs-mode: nil
;; End:

;; LocalWords:  reproducibility workflows installable stateful
;; LocalWords:  expressivity verifiability
